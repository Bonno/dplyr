// Generated by CoffeeScript 1.7.1
'use strict';
exports.cleanTrack = function(track) {
  delete track.votes;
  delete track.votesHash;
  return delete track.updated;
};

exports.search = function(m, query, done) {
  var gotError, gotResults, promise;
  promise = m.library.search({
    any: query
  });
  gotResults = function(results) {
    var instances, searchResults, tracks, _i, _len;
    tracks = [];
    instances = [];
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      searchResults = results[_i];
      tracks.push.apply(tracks, searchResults.tracks);
    }
    return done(null, tracks);
  };
  gotError = function(err) {
    return done(err);
  };
  return promise.then(gotResults, gotError);
};

exports.onError = function(err) {
  return console.error(err.stack);
};

exports.clear = function(m, done) {
  var gotCurrentTrack, gotIndex, gotPrevious, gotTracks, onError, onRemove, s;
  onError = function(err) {
    return done(err);
  };
  s = {};
  gotCurrentTrack = function(tlTrack) {
    if (tlTrack) {
      return m.tracklist.index(tlTrack).then(gotIndex, onError);
    } else {
      return gotPrevious([]);
    }
  };
  gotIndex = function(index) {
    s.current = index;
    if (0 >= index) {
      return gotPrevious([]);
    } else {
      return m.tracklist.slice(0, index).then(gotPrevious, onError);
    }
  };
  gotPrevious = function(tlTracks) {
    s.previous = tlTracks;
    return m.tracklist.slice(s.current + 1, Infinity).then(gotTracks, onError);
  };
  gotTracks = function(tracks) {
    var ids, track;
    tracks || (tracks = []);
    tracks.push.apply(tracks, s.previous);
    ids = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tracks.length; _i < _len; _i++) {
        track = tracks[_i];
        _results.push(track.tlid);
      }
      return _results;
    })();
    return m.tracklist.remove({
      tlid: ids
    }).then(onRemove, onError);
  };
  onRemove = function() {
    return done();
  };
  return m.playback.getCurrentTlTrack().then(gotCurrentTrack, onError);
};

exports.setNextTrack = function(m, track, done) {
  var onAdd, onClear, onError;
  onError = function(err) {
    return done(err);
  };
  exports.cleanTrack(track);
  onClear = function(err) {
    if (err) {
      return done(err);
    }
    return m.tracklist.add([track], null).then(onAdd, onError);
  };
  onAdd = function() {
    return done();
  };
  return exports.clear(m, onClear);
};
